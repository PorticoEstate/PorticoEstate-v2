
//#region src/utils.ts
const QUICK_EVENT = {
	passive: true,
	capture: true
};
const isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
const isWindows = () => isBrowser() && /^Win/i.test(navigator.userAgentData?.platform || navigator.platform);
const DSElement = typeof HTMLElement === "undefined" ? class {} : HTMLElement;
function debounce(callback, delay) {
	let timer;
	return function(...args) {
		clearTimeout(timer);
		timer = setTimeout(() => callback.apply(this, args), delay);
	};
}
/**
* attr
* @description Utility to quickly get, set and remove attributes
* @param el The Element to read/write attributes from
* @param name The attribute name to get, set or remove, or a object to set multiple attributes
* @param value A valid attribute value or null to remove attribute
*/
const attr = (el, name, value) => {
	if (value === void 0) return el.getAttribute(name) ?? null;
	if (value === null) el.removeAttribute(name);
	else if (el.getAttribute(name) !== value) el.setAttribute(name, value);
	return null;
};
/**
* attrRequiredWarning
* @description Warn if element is missing attribute
* @param el The Element to read/write attributes from
* @param ...names The attribute name(s) check
*/
const attrRequiredWarning = (el, name) => el.hasAttribute(name) || console.warn(`Designsystemet: Missing a ${name} attribute`, el);
/**
* on
* @param el The Element to use as EventTarget
* @param types A space separated string of event types
* @param listener An event listener function or listener object
*/
const on = (el, ...rest) => {
	const [types, ...options] = rest;
	for (const type of types.split(" ")) el.addEventListener(type, ...options);
	return () => off(el, ...rest);
};
/**
* off
* @param el The Element to use as EventTarget
* @param types A space separated string of event types
* @param listener An event listener function or listener object
*/
const off = (el, ...rest) => {
	const [types, ...options] = rest;
	for (const type of types.split(" ")) el.removeEventListener(type, ...options);
};
/**
* onHotReload
* @description Runs a callback when window is loaded in browser, and ensures cleanup when hot-reloading
* @param key The key to identify setup and corresponding cleanup
* @param callback The callback to run when the page is ready
*/
const onHotReload = (key, setup) => {
	if (!isBrowser()) return;
	if (!window._dsHotReloadCleanup) window._dsHotReloadCleanup = /* @__PURE__ */ new Map();
	const run = () => {
		window._dsHotReloadCleanup?.get(key)?.map((cleanup) => cleanup());
		window._dsHotReloadCleanup?.set(key, setup());
	};
	if (document.readyState !== "complete") on(window, "load", run);
	else document.fonts?.ready?.then(run) || setTimeout(run, 0);
};
/**
* Speed up MutationObserver by debouncing and only running when page is visible
* @return new MutaionObserver
*/
const onMutation = (el, callback, options) => {
	let queue = 0;
	const { debounce: ms = 200, ...opts } = options;
	const onTimer = () => {
		if (!isBrowser()) return cleanup();
		callback(observer);
		observer.takeRecords();
		queue = 0;
	};
	const onFrame = ms ? debounce(onTimer, ms) : onTimer;
	const cleanup = () => observer?.disconnect?.();
	const observer = new MutationObserver(() => {
		if (!queue) queue = requestAnimationFrame(onFrame);
	});
	observer.observe(el, opts);
	onFrame();
	return cleanup;
};
if (isBrowser()) {
	let isSupported = false;
	const dialog = document.createElement("dialog");
	dialog.addEventListener("beforetoggle", (e) => {
		isSupported = "source" in e;
	});
	dialog.show();
	if (!isSupported) Object.defineProperty(ToggleEvent.prototype, "source", {
		configurable: true,
		enumerable: true,
		get() {
			const id = this.target.id;
			const root = this.target.getRootNode();
			const css = `[popovertarget="${id}"],[commandfor="${id}"]`;
			return id ? root?.querySelector?.(css) : null;
		}
	});
}
/**
* tag
* @description creates element and assigns properties
* @param tagName The tagname of element to create
* @param attrs Optional attributes to add to the element
* @param text Optional text content to add to the element
* @return HTMLElement with props
*/
const tag = (tagName, attrs) => {
	const el = document.createElement(tagName);
	if (attrs) for (const [key, val] of Object.entries(attrs)) attr(el, key, val);
	return el;
};
/**
* customElements.define
* @description Defines a customElement if running in browser and if not already registered
* Scoped/named "customElements.define" so @custom-elements-manifest/analyzer can find tag names
*/
const customElements = { define: (name, instance) => !isBrowser() || window.customElements.get(name) || window.customElements.define(name, instance) };
/**
* useId
* @return A generated unique ID
*/
let id = 0;
const hash = `${Date.now().toString(36)}${Math.random().toString(36).slice(2, 5)}`;
function useId(el) {
	if (el && !el.id) el.id = `${hash}${++id}`;
	return el?.id || "";
}

//#endregion
exports.DSElement = DSElement;
exports.QUICK_EVENT = QUICK_EVENT;
exports.attr = attr;
exports.attrRequiredWarning = attrRequiredWarning;
exports.customElements = customElements;
exports.debounce = debounce;
exports.isBrowser = isBrowser;
exports.isWindows = isWindows;
exports.off = off;
exports.on = on;
exports.onHotReload = onHotReload;
exports.onMutation = onMutation;
exports.tag = tag;
exports.useId = useId;
//# sourceMappingURL=utils.cjs.map