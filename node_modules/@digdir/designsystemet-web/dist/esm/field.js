import { DSElement, QUICK_EVENT, attr, customElements, debounce, isBrowser, isWindows, off, on, onHotReload, onMutation, tag, useId } from "./utils.js";

//#region src/field.ts
const CSS_FIELD_SIZE = "--_ds-field-sizing";
const ATTR_COUNTER_TEXT = "data-counter-text";
const ATTR_COUNTER_ARIA = "data-counter-aria";
const ATTR_FIELD = "data-field";
const TYPE_DESCRIPTION = "description";
const TYPE_VALIDATION = "validation";
const COUNTER_DEBOUNCE = isWindows() ? 800 : 200;
const COUNTER_TEXT = {
	over: "%d tegn for mye",
	under: "%d tegn for mye",
	hint: "Maks %d tegn tillatt."
};
const SELECTOR_FIELDSET_DESCRIPTION = `:scope > [${ATTR_FIELD}="${TYPE_DESCRIPTION}"],:scope > legend + p`;
const SELECTOR_FIELDSET_VALIDATION = `:scope > [${ATTR_FIELD}="${TYPE_VALIDATION}"]`;
const SELECTOR_FIELD_COUNTER = "[data-field=\"counter\"]";
const FIELDS = /* @__PURE__ */ new Set();
const FILEDSETS = isBrowser() ? document.getElementsByTagName("fieldset") : [];
const STYLE_SR_ONLY = `position:absolute;clip:rect(0 0 0 0);overflow:hidden;width:1px;height:1px;white-space:nowrap;pointer-events:none`;
const handleMutations = debounce(() => {
	setupFieldsets();
	setupFields();
}, 100);
const setupFieldsets = () => {
	for (const fieldset of FILEDSETS) attr(fieldset, "aria-labelledby", [fieldset.querySelector("legend"), fieldset.querySelector(SELECTOR_FIELDSET_DESCRIPTION)].filter(isNotHidden).map(useId).join(" "));
};
const setupFields = () => {
	for (const field of FIELDS) {
		const descs = [];
		const labels = [];
		let input;
		for (const el of field.getElementsByTagName("*")) if (el instanceof HTMLLabelElement) labels.push(el);
		else if (isInputLike(el)) {
			if (input) console.warn(`Designsystemet: Fields should only have one input element. Use <fieldset> to group multiple fields:`, field);
			input = el;
		} else if (isNotHidden(el)) {
			const type = el.getAttribute(ATTR_FIELD);
			if (type === TYPE_VALIDATION) descs.unshift(el);
			else if (type) descs.push(el);
		}
		if (!input) console.warn(`Designsystemet: Field is missing input element:`, field);
		else {
			for (const label of labels) attr(label, "for", useId(input));
			const isBoolish = input.type === "radio" || input.type === "checkbox";
			const fieldsetValidation = field.closest("fieldset")?.querySelector(SELECTOR_FIELDSET_VALIDATION);
			if (isNotHidden(fieldsetValidation)) descs.unshift(fieldsetValidation);
			field.handleEvent({ target: input });
			attr(field, "data-clickdelegatefor", isBoolish ? useId(input) : null);
			attr(input, "aria-describedby", descs.map(useId).join(" "));
			attr(input, "aria-invalid", `${descs.some(isInvalid)}`);
		}
	}
};
const getCounterText = (el, key, num) => (attr(el, `data-${key}`) || COUNTER_TEXT[key]).replace("%d", `${Math.abs(num)}`);
const setupCounter = (field, target) => {
	const el = isInputLike(target) && field.querySelector(SELECTOR_FIELD_COUNTER);
	if (el) {
		const live = field.shadowRoot?.lastElementChild;
		const limit = Number(attr(el, "data-limit")) || 0;
		const count = limit - target.value.length;
		const text = getCounterText(el, count < 0 ? "over" : "under", count);
		attr(el, ATTR_COUNTER_TEXT, text);
		attr(el, ATTR_COUNTER_ARIA, getCounterText(el, "hint", limit));
		attr(el, "data-color", count < 0 ? "danger" : null);
		setupCounterLiveRegion(live, text);
	}
};
const setupCounterLiveRegion = debounce((live, text) => {
	live.textContent = text;
}, COUNTER_DEBOUNCE);
const setupTextareaFieldSizingiOS = (target) => {
	if (target instanceof HTMLTextAreaElement) {
		target.style.setProperty(CSS_FIELD_SIZE, "auto");
		target.style.setProperty(CSS_FIELD_SIZE, `${target.scrollHeight}px`);
	}
};
const isInputLike = (el) => el instanceof HTMLElement && "validity" in el && !(el instanceof HTMLButtonElement);
const isNotHidden = (el) => !!el && !el.hidden;
const isInvalid = (el) => el.getAttribute(ATTR_FIELD) === TYPE_VALIDATION && attr(el, "data-color") !== "success";
var DSFieldElement = class extends DSElement {
	constructor() {
		super();
		this.attachShadow({ mode: "open" }).append(tag("slot"), tag("div", {
			"aria-live": "polite",
			style: STYLE_SR_ONLY
		}));
	}
	connectedCallback() {
		FIELDS.add(this);
		on(this, "input", this, QUICK_EVENT);
		handleMutations();
	}
	handleEvent({ target }) {
		setupCounter(this, target);
		setupTextareaFieldSizingiOS(target);
	}
	disconnectedCallback() {
		off(this, "input", this, QUICK_EVENT);
		FIELDS.delete(this);
	}
};
customElements.define("ds-field", DSFieldElement);
onHotReload("field", () => [onMutation(document, handleMutations, {
	debounce: false,
	attributeFilter: ["hidden", ATTR_FIELD],
	attributes: true,
	childList: true,
	subtree: true
})]);

//#endregion
export { DSFieldElement };
//# sourceMappingURL=field.js.map