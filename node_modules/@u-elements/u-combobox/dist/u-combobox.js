var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// ../utils.ts
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_ANDROID = IS_BROWSER && /android/i.test(navigator.userAgent);
var IS_IOS = IS_BROWSER && /iPad|iPhone|iPod/.test(navigator.userAgent);
var _a;
IS_BROWSER && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a = navigator.userAgentData) == null ? void 0 : _a.platform) || navigator.platform);
var FOCUS_OUTLINE = "outline: 1px dotted; outline: 5px auto Highlight; outline: 5px auto -webkit-focus-ring-color";
var UHTMLElement = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr(el, name, value) {
  if (value === void 0) return el.getAttribute(name);
  if (value === null) el.removeAttribute(name);
  else if (el.getAttribute(name) !== value) el.setAttribute(name, value);
  return null;
}
var events = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on = (element, ...rest) => events("add", element, rest);
var off = (element, ...rest) => events("remove", element, rest);
var observers = /* @__PURE__ */ new WeakMap();
var mutationObserver = (element, options) => {
  if (options === void 0) return observers.get(element);
  try {
    observers.get(element).disconnect();
    observers.delete(element);
  } catch (_err) {
  }
  if (options) {
    const observer = new MutationObserver(
      (detail) => element.handleEvent({ type: "mutation", detail })
    );
    observer.observe(element, options);
    observers.set(element, observer);
  }
};
var asButton = (event) => {
  var _a2;
  const isClick = event.key === " " || event.key === "Enter";
  if (isClick) (_a2 = event.preventDefault) == null ? void 0 : _a2.call(event);
  if (isClick && event.target instanceof HTMLElement)
    event.target.dispatchEvent(new MouseEvent("click", event));
  return isClick;
};
var getRoot = (node) => {
  var _a2;
  const root = ((_a2 = node.getRootNode) == null ? void 0 : _a2.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id = 0;
var useId = (el) => {
  if (!el) return "";
  if (!el.id) el.id = `:${el.nodeName.toLowerCase()}${(++id).toString(32)}`;
  return el.id;
};
var createElement = (tagName, content, attrs) => {
  const el = document.createElement(tagName);
  if (content) el[tagName === "style" ? "textContent" : "innerHTML"] = content;
  if (attrs) for (const [key, val] of Object.entries(attrs)) attr(el, key, val);
  return el;
};
var customElements = {
  define: (name, instance) => !IS_BROWSER || window.customElements.get(name) || window.customElements.define(name, instance)
};
var getLabel = (el) => {
  var _a2;
  const label = attr(el, "aria-label") || "";
  const labels = ((_a2 = attr(el, "aria-labelledby")) == null ? void 0 : _a2.trim().split(/\s+/)) || [];
  return [
    ...labels.map((id2) => document.getElementById(id2)),
    // Get all labelledby elements
    ...Array.from(el.labels || [])
    // Get all <label> elements
  ].reduce((acc, el2) => {
    var _a3;
    return acc || ((_a3 = el2 == null ? void 0 : el2.innerText) == null ? void 0 : _a3.trim()) || "";
  }, label);
};
var LIVE;
var LIVE_SR_FIX = 0;
var speak = (text2) => {
  if (!LIVE) {
    LIVE = createElement("div");
    LIVE.style.cssText = "position:fixed;overflow:hidden;width:1px;white-space:nowrap";
    attr(LIVE, "aria-live", "assertive");
  }
  if (!LIVE.isConnected) document.body.append(LIVE);
  if (text2) LIVE.textContent = `${text2}${LIVE_SR_FIX++ % 2 ? "\xA0" : ""}`;
};
var setValue = (input, data, type = "") => {
  var _a2, _b;
  const event = { bubbles: true, composed: true, data, inputType: type };
  const proto = HTMLInputElement.prototype;
  input.dispatchEvent(new InputEvent("beforeinput", event));
  (_b = (_a2 = Object.getOwnPropertyDescriptor(proto, "value")) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(input, data);
  input.dispatchEvent(new InputEvent("input", event));
  input.dispatchEvent(new Event("change", { bubbles: true }));
};
var IS_PRESS = false;
var isMouseDown = (event) => {
  if ((event == null ? void 0 : event.type) === "mouseup") IS_PRESS = false;
  if ((event == null ? void 0 : event.type) === "mousedown") {
    IS_PRESS = true;
    on(document, "mouseup", isMouseDown, { once: true });
  }
  return IS_PRESS;
};
var declarativeShadowRoot = (style, slot = "<slot></slot>") => `<template shadowrootmode="open">${slot}<style>${style}</style></template>`;

// u-combobox.ts
var UHTMLComboboxStyle = `:host(:not([hidden])) { display: block; -webkit-tap-highlight-color: rgba(0, 0, 0, 0) } /* Must be display block in Safari to allow focus inside */
:host(:not([data-multiple])) ::slotted(data),
:host([data-multiple="false"]) ::slotted(data) { display: none } /* Hide data if not multiple */
[role="listbox"] { position: absolute } /* Avoid affecting CSS like flex on the <u-combobox> */
::slotted(input[inputmode="none"]) { outline: none } /* Hide temporary foucs outline flash */
::slotted(del) { text-decoration: none }
::slotted(data:not([hidden])) { display: inline-block; pointer-events: none }
::slotted(data)::after { content: '\\00D7'; content: '\\00D7' / ''; padding-inline: .5ch; pointer-events: auto; cursor: pointer }
::slotted(data:focus) { ${FOCUS_OUTLINE} }`;
var UHTMLComboboxShadowRoot = declarativeShadowRoot(UHTMLComboboxStyle);
var EVENTS = "beforeinput,blur,focus,click,input,keydown,mousedown";
var EVENT_ONCE = { once: true, capture: true, passive: true };
var FALSE = "false";
var IS_MOBILE = IS_ANDROID || IS_IOS;
var MODIFIED = "\u200B".repeat(5);
var VALUE_DELETE = "deleteContentBackward";
var VALUE_INSERT = "insertText";
var WHITE_SPACE = "\xA0";
var TEXTS = {
  added: "Added",
  empty: "No selected",
  found: "Navigate left to find %d selected",
  invalid: "Invalid value",
  items: "Selected",
  // Note: Not announced by NVDA
  of: "of",
  remove: "Press to remove",
  removed: "Removed"
};
var UHTMLComboboxElement = class extends UHTMLElement {
  constructor() {
    super();
    this._item = "";
    this._speak = "";
    this._texts = __spreadValues({}, TEXTS);
    this._value = "";
    if (!this.shadowRoot)
      this.attachShadow({ mode: "open" }).append(
        createElement("slot", null, {
          "aria-orientation": "horizontal",
          tabindex: "-1",
          role: "listbox",
          // Note: Not announced by JAWS
          name: "items"
        }),
        createElement("slot"),
        // Used to prevent exiting JAWS forms mode when an item is removed, using listbox as this forces JAWS to stay in forms mode without mobile keyboard opening
        createElement("div", '<div role="option" tabindex="-1"></div>', {
          "aria-hidden": "true",
          // Prevent screen readers from announcing this element
          role: "listbox"
        }),
        createElement("style", UHTMLComboboxStyle)
      );
  }
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return Object.keys(TEXTS).map((key) => `data-sr-${key}`);
  }
  connectedCallback() {
    this._root = getRoot(this);
    on(this, EVENTS, this, true);
    mutationObserver(this, {
      attributeFilter: ["value", "id", "role"],
      // Respond to changes in <data> value or change of id or role for <datalist> to reconnect with input
      attributes: true,
      characterData: true,
      // Respond to changes in <data> textContent
      childList: true,
      subtree: true
    });
    setTimeout(render, 0, this);
    setTimeout(syncInputValue, 0, this);
  }
  attributeChangedCallback(prop, _, val) {
    const text2 = prop.split("data-sr-")[1];
    if (TEXTS[text2]) this._texts[text2] = val || TEXTS[text2];
  }
  disconnectedCallback() {
    mutationObserver(this, false);
    off(this, EVENTS, this, true);
    this._items = this._clear = this._focus = this._control = void 0;
    this._list = this._options = this._root = this._form = void 0;
  }
  handleEvent(event) {
    const target = event.target;
    if (isDisabled(this)) return;
    if (event.type === "beforeinput") this._value = (target == null ? void 0 : target.value) || "";
    if (event.type === "blur") onBlur(this);
    if (event.type === "click") onClick(this, event);
    if (event.type === "focus") onFocus(this, event);
    if (event.type === "input") onInput(this, event);
    if (event.type === "keydown") onKeyDown(this, event);
    if (event.type === "mousedown") isMouseDown(event);
    if (event.type === "mutation") render(this, event);
  }
  get multiple() {
    var _a2;
    return ((_a2 = attr(this, "data-multiple")) != null ? _a2 : FALSE) !== FALSE;
  }
  set multiple(value) {
    attr(this, "data-multiple", value ? "" : null);
  }
  get creatable() {
    var _a2;
    return ((_a2 = attr(this, "data-creatable")) != null ? _a2 : FALSE) !== FALSE;
  }
  set creatable(value) {
    attr(this, "data-creatable", value ? "" : null);
  }
  get control() {
    var _a2;
    if (!((_a2 = this._control) == null ? void 0 : _a2.isConnected))
      this._control = this.querySelector("input");
    return this._control;
  }
  get list() {
    var _a2;
    if (!((_a2 = this._list) == null ? void 0 : _a2.isConnected))
      this._list = this.querySelector('datalist,[role="listbox"]');
    return this._list;
  }
  get clear() {
    var _a2;
    if (!((_a2 = this._clear) == null ? void 0 : _a2.isConnected)) this._clear = this.querySelector("del");
    return this._clear;
  }
  get items() {
    if (!this._items) this._items = this.getElementsByTagName("data");
    return this._items;
  }
  get options() {
    var _a2, _b;
    if (!this._options) {
      const tag = (_b = (_a2 = this.list) == null ? void 0 : _a2.querySelector('[role="option"],option')) == null ? void 0 : _b.nodeName;
      if (tag) this._options = this.getElementsByTagName(tag);
    }
    return this._options;
  }
  get values() {
    return [...this.items].map(({ value }) => value);
  }
};
var text = (el) => {
  var _a2;
  return ((_a2 = el == null ? void 0 : el.textContent) == null ? void 0 : _a2.trim()) || "";
};
var isData = (el) => el instanceof HTMLDataElement;
var isDisabled = ({ control }) => (control == null ? void 0 : control.disabled) || (control == null ? void 0 : control.readOnly) || false;
var render = (self, event) => {
  var _a2, _b;
  const { _focus, _texts, items, control, list, multiple } = self;
  if (!control) return;
  const prev = getLabel(control);
  const next = prev.endsWith(MODIFIED) ? attr(control, "data-label") : prev;
  attr(control, "data-label", next);
  let label = `${next}${multiple ? `, ${items.length ? _texts.found.replace("%d", `${items.length}`) : _texts.empty}` : ""}`;
  const edits = [];
  for (const { addedNodes, removedNodes } of (event == null ? void 0 : event.detail) || []) {
    for (const el of addedNodes) if (isData(el)) edits.unshift(el);
    for (const el of removedNodes) if (isData(el)) edits.push(el);
  }
  const shouldAnnounce = multiple ? edits.length === 1 : edits[0] === _focus;
  if (_focus && shouldAnnounce) {
    const ariaExpanded = attr(control, "aria-expanded");
    const inputMode = attr(control, "inputmode");
    const nextFocus = isData(_focus) ? control : _focus;
    const isRemove = !edits[0].isConnected;
    self._speak = `${_texts[isRemove ? "removed" : "added"]} ${text(edits[0])}, `;
    if (IS_MOBILE || _focus === control) speak(self._speak);
    if (control !== nextFocus) {
      if (IS_MOBILE) attr(control, "aria-expanded", null);
      if (IS_MOBILE) attr(control, "inputmode", "none");
      label = WHITE_SPACE;
      control.focus();
    }
    setTimeout(() => {
      var _a3;
      attr(control, "aria-expanded", ariaExpanded);
      attr(control, "inputmode", isRemove ? "none" : inputMode);
      (_a3 = nextFocus == null ? void 0 : nextFocus.focus) == null ? void 0 : _a3.call(nextFocus);
      attr(control, "inputmode", inputMode);
      self._speak = "";
      if (IS_MOBILE)
        setTimeout(render, 100, self);
      else on(self, "blur", () => render(self), EVENT_ONCE);
    }, 100);
  }
  let idx = 0;
  const select = self.querySelector("select");
  const remove = isDisabled(self) ? "" : _texts.remove;
  const itemsList = (_a2 = self.shadowRoot) == null ? void 0 : _a2.firstElementChild;
  if (itemsList) attr(itemsList, "aria-label", _texts.items);
  for (const item2 of items) {
    const option = select == null ? void 0 : select.options[idx++];
    const label2 = text(item2);
    const value = item2.value || label2;
    const aria = `${self._speak}${label2}, ${remove}`;
    attr(item2, "aria-label", aria);
    attr(item2, "aria-selected", "true");
    attr(item2, "role", "option");
    attr(item2, "slot", "items");
    attr(item2, "tabindex", "-1");
    attr(item2, "value", value);
    if (option) Object.assign(option, { textContent: label2, value });
    else select == null ? void 0 : select.appendChild(new Option(label2, value, true, true));
    if (IS_IOS) attr(item2, "title", `${idx} ${_texts.of} ${items.length}`);
  }
  if (select) attr(select, "multiple", multiple ? "" : null);
  for (const opt of [...(select == null ? void 0 : select.options) || []].slice(idx)) opt.remove();
  if (!multiple && idx > 1)
    console.warn(self, ` Multiple <data> found in single mode.`);
  if (list) {
    attr(list, "aria-multiselectable", `${multiple}`);
    attr(control, "list", useId(list));
    attr(control, "aria-label", `${self._speak}${label}${MODIFIED}`);
    if (list.hasAttribute("popover")) {
      attr(control, "popovertarget", useId(list));
      attr(list, "popover", "manual");
    }
    list._of = _texts.of;
  }
  const item = text(items[0]);
  if (item !== self._item) syncInputValue(self);
  self._item = item;
  syncClearWithInput(self);
  syncOptionsWithItems(self);
  (_b = mutationObserver(self)) == null ? void 0 : _b.takeRecords();
};
var syncClearWithInput = (self) => {
  var _a2;
  if (self.clear) attr(self.clear, "role", "button");
  if (self.clear) self.clear.hidden = !((_a2 = self.control) == null ? void 0 : _a2.value) || isDisabled(self);
};
var syncOptionsWithItems = (self) => {
  var _a2;
  const { _speak, options = [], values } = self;
  for (const opt of options) {
    const value = (_a2 = attr(opt, "value")) != null ? _a2 : text(opt);
    attr(opt, "aria-label", _speak ? `${_speak}${text(opt)}` : null);
    attr(opt, "selected", values.includes(value) ? "" : null);
  }
};
var syncInputValue = (self) => {
  const { multiple, control, items } = self;
  const value = text(items[0]);
  if (!multiple && control && value !== control.value)
    setValue(control, value, value ? VALUE_INSERT : VALUE_DELETE);
};
var dispatchMatch = (self, change = true) => {
  var _a2;
  const { _texts, options = [], creatable, control, items, multiple } = self;
  const value = ((_a2 = control == null ? void 0 : control.value) == null ? void 0 : _a2.trim()) || "";
  const query = value.toLowerCase() || null;
  let match = [...options].find(
    (opt) => (attr(opt, "label") || text(opt)).trim().toLowerCase() === query
  );
  const event = { bubbles: true, cancelable: true, detail: match };
  if (!self.dispatchEvent(new CustomEvent("comboboxbeforematch", event)))
    match = [...options].find((o) => o.selected);
  if (change) {
    syncOptionsWithItems(self);
    if (match) return dispatchChange(self, match, false);
    if (creatable && value) return dispatchChange(self, { value }, false);
    if (!multiple && !value && items[0]) dispatchChange(self, items[0]);
    else syncInputValue(self);
    return speak(_texts.invalid);
  }
  for (const opt of options) opt.selected = opt === match;
};
var dispatchChange = (self, item, removable = true) => {
  var _a2, _b, _c;
  const { control, items, multiple } = self;
  const add = createElement("data", item.label || item.value, {
    value: item.value
  });
  const remove = [...items].find((i) => i.value === item.value);
  const event = { bubbles: true, cancelable: true, detail: remove || add };
  const skip = remove && !removable;
  if (skip) return syncInputValue(self);
  if (remove === ((_a2 = getRoot(self)) == null ? void 0 : _a2.activeElement))
    (_c = (_b = self.shadowRoot) == null ? void 0 : _b.querySelector('[role="option"]')) == null ? void 0 : _c.focus();
  if (self.dispatchEvent(new CustomEvent("comboboxbeforeselect", event))) {
    if (!multiple) for (const item2 of [...items]) item2.remove();
    if (remove) remove.remove();
    else control == null ? void 0 : control.insertAdjacentElement("beforebegin", add);
    self.dispatchEvent(new CustomEvent("comboboxafterselect", event));
  }
};
var onFocus = (self, { target }) => {
  const { _form, control, multiple } = self;
  if (target instanceof HTMLElement) self._focus = target;
  if (multiple && _form === void 0 && control && target === control) {
    self._form = attr(control, "form");
    attr(control, "form", "#");
  }
  speak();
};
var onBlur = (self) => isMouseDown() || setTimeout(onBlurred, 0, self);
var onBlurred = (self) => {
  const { _focus, _root, _form, multiple, control } = self;
  if (!_focus || self.contains(_root == null ? void 0 : _root.activeElement)) return;
  if (!multiple) dispatchMatch(self);
  if (_form && control) attr(control, "form", _form);
  self._focus = self._form = void 0;
};
var onClick = (self, event) => {
  const { clientX: x, clientY: y, target } = event;
  const { clear, control, items } = self;
  if (clear == null ? void 0 : clear.contains(target)) {
    if (control) setValue(control, "", VALUE_DELETE);
    return control == null ? void 0 : control.focus();
  }
  for (const item of items) {
    const { top, right, bottom, left } = item.getBoundingClientRect();
    if (item.contains(target)) return dispatchChange(self, item);
    if (y >= top && y <= bottom && x >= left && x <= right) return item.focus();
  }
  if (target === self) control == null ? void 0 : control.focus();
};
var onInput = (self, event) => {
  var _a2;
  const { options = [], control, multiple } = self;
  const value = ((_a2 = control == null ? void 0 : control.value) == null ? void 0 : _a2.trim()) || "";
  const isClick = event instanceof InputEvent ? !event.inputType || event.inputType === "insertReplacementText" : !!value;
  if (isClick) {
    event.stopImmediatePropagation();
    if (control) control.value = self._value;
    for (const opt of options)
      if (opt.value && opt.value === value)
        return dispatchChange(self, opt, multiple);
  } else if (!multiple) dispatchMatch(self, false);
  syncClearWithInput(self);
};
var onKeyDown = (self, event) => {
  var _a2;
  const { clear, control, items } = self;
  const { key, repeat, target } = event;
  const isControl = control && control === target;
  const inText = isControl && control.selectionEnd;
  const isModified = event.ctrlKey || event.metaKey || event.shiftKey || event.key === "Alt";
  let index = isControl ? items.length : [...items].indexOf(target);
  if (isControl && key === "Tab" && !event.shiftKey && clear && !clear.hidden) {
    event.preventDefault();
    clear.tabIndex = 0;
    clear.focus();
    on(clear, "blur", () => attr(clear, "tabindex", null), EVENT_ONCE);
  }
  if (!isControl && asButton(event) || index === -1 || isModified) return;
  if (key === "ArrowRight" && !isControl) index += 1;
  else if (key === "ArrowLeft" && !inText) index -= 1;
  else if (key === "Enter" && isControl) return dispatchMatch(self);
  else if (key === "Backspace" && !inText) {
    event.preventDefault();
    if (!repeat && items[index]) return dispatchChange(self, items[index]);
    if (isControl) index -= 1;
  } else return isControl || (control == null ? void 0 : control.focus());
  event.preventDefault();
  (_a2 = items[Math.max(0, index)] || control) == null ? void 0 : _a2.focus();
};
customElements.define("u-combobox", UHTMLComboboxElement);

export { UHTMLComboboxElement, UHTMLComboboxShadowRoot, UHTMLComboboxStyle };
