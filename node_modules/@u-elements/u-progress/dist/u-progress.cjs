'use strict';

// ../utils.ts
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_FIREFOX = IS_BROWSER && /firefox/i.test(navigator.userAgent);
var IS_IOS = IS_BROWSER && /iPad|iPhone|iPod/.test(navigator.userAgent);
var _a;
IS_BROWSER && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a = navigator.userAgentData) == null ? void 0 : _a.platform) || navigator.platform);
var UHTMLElement = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr(el, name, value) {
  if (value === void 0) return el.getAttribute(name);
  if (value === null) el.removeAttribute(name);
  else if (el.getAttribute(name) !== value) el.setAttribute(name, value);
  return null;
}
var getRoot = (node) => {
  var _a2;
  const root = ((_a2 = node.getRootNode) == null ? void 0 : _a2.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id = 0;
var useId = (el) => {
  if (!el) return "";
  if (!el.id) el.id = `:${el.nodeName.toLowerCase()}${(++id).toString(32)}`;
  return el.id;
};
var createElement = (tagName, text, attrs) => {
  const el = document.createElement(tagName);
  if (text) el.textContent = text;
  if (attrs) for (const [key, val] of Object.entries(attrs)) attr(el, key, val);
  return el;
};
var customElements = {
  define: (name, instance) => !IS_BROWSER || window.customElements.get(name) || window.customElements.define(name, instance)
};
var getLabel = (el) => {
  var _a2;
  const label = attr(el, "aria-label") || "";
  const labels = ((_a2 = attr(el, "aria-labelledby")) == null ? void 0 : _a2.trim().split(/\s+/)) || [];
  return [
    ...labels.map((id2) => document.getElementById(id2)),
    // Get all labelledby elements
    ...Array.from(el.labels || [])
    // Get all <label> elements
  ].reduce((acc, el2) => {
    var _a3;
    return acc || ((_a3 = el2 == null ? void 0 : el2.innerText) == null ? void 0 : _a3.trim()) || "";
  }, label);
};
var declarativeShadowRoot = (style, slot = "<slot></slot>") => `<template shadowrootmode="open">${slot}<style>${style}</style></template>`;

// u-progress.ts
var UHTMLProgressStyle = `:host(:not([hidden])) { box-sizing: border-box; border: 1px solid; display: inline-block; height: .5em; width: 10em; overflow: hidden }
:host::before { content: ''; display: block; height: 100%; background: currentColor; width: var(--percentage, 0%); transition: width .2s }
:host(:not([value])) { background: linear-gradient(90deg,currentColor 25%, transparent 50%, currentColor 75%) 50%/400% }
@media (prefers-reduced-motion: no-preference) { :host { animation: indeterminate 2s linear infinite }  }
@keyframes indeterminate { from { background-position-x: 100% } to { background-position-x: 0 } }`;
var UHTMLProgressShadowRoot = declarativeShadowRoot(
  UHTMLProgressStyle,
  "<slot hidden></slot>"
);
var SKIP_ATTR_CHANGE = false;
var UHTMLProgressElement = class extends UHTMLElement {
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["aria-label", "aria-labelledby", "value", "max"];
  }
  constructor() {
    super();
    if (!this.shadowRoot)
      this.attachShadow({ mode: "open" }).append(
        createElement("slot", null, { hidden: "" }),
        // Slot hiding content allows legacy browser to display fallback text
        createElement("style", UHTMLProgressStyle)
      );
  }
  connectedCallback() {
    this.attributeChangedCallback();
  }
  attributeChangedCallback() {
    if (SKIP_ATTR_CHANGE) return;
    SKIP_ATTR_CHANGE = true;
    const roleImage = IS_IOS || IS_FIREFOX;
    const percentage = Math.max(0, Math.round(this.position * 100));
    this.style.setProperty("--percentage", `${percentage}%`);
    let label = getLabel(this);
    if (roleImage) label = `${label.replace(/\d+%$/, "")} ${percentage}%`;
    if (IS_FIREFOX) for (const el of this.labels) attr(el, "aria-label", label);
    attr(this, "aria-busy", `${this.position === -1}`);
    attr(this, "aria-label", label.trim());
    attr(this, "aria-labelledby", null);
    attr(this, "aria-valuemax", "100");
    attr(this, "aria-valuemin", "0");
    attr(this, "aria-valuenow", `${percentage}`);
    attr(this, "role", roleImage ? "img" : "progressbar");
    SKIP_ATTR_CHANGE = false;
  }
  get labels() {
    const label = this.closest("label:not([for])");
    const id2 = useId(this);
    if (label) label.htmlFor = id2;
    const el = getRoot(this).querySelectorAll(
      `label[for="${id2}"]`
    );
    return el;
  }
  get position() {
    return this.value === null ? -1 : Math.min(this.value / this.max, 1);
  }
  get value() {
    return getNumber(this, "value");
  }
  set value(value) {
    setNumber(this, "value", value);
  }
  get max() {
    return getNumber(this, "max") || 1;
  }
  set max(max) {
    setNumber(this, "max", max);
  }
};
// Prevent Chrome DevTools warning about <label for=""> pointing to <u-progress>
UHTMLProgressElement.formAssociated = true;
var isNumeric = (value) => !Number.isNaN(Number.parseFloat(`${value}`)) && Number.isFinite(Number(value));
var getNumber = (el, key) => {
  const value = attr(el, key);
  return isNumeric(value) ? Math.max(0, Number.parseFloat(value)) : null;
};
var setNumber = (el, key, val) => {
  if (val === null || isNumeric(val)) attr(el, key, `${val}`);
  else throw new Error(`Failed to set non-numeric '${attr}': '${val}'`);
};
customElements.define("u-progress", UHTMLProgressElement);

exports.UHTMLProgressElement = UHTMLProgressElement;
exports.UHTMLProgressShadowRoot = UHTMLProgressShadowRoot;
exports.UHTMLProgressStyle = UHTMLProgressStyle;
