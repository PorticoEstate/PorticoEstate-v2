{"version":3,"file":"utils.cjs","names":[],"sources":["../../src/utils.ts"],"sourcesContent":["export const QUICK_EVENT = { passive: true, capture: true };\r\n\r\n// Using function instead of constant to support evnironments where DOM can be unloaded (like Vitest with jsdom)\r\nexport const isBrowser = () =>\r\n  typeof window !== 'undefined' && typeof document !== 'undefined';\r\n\r\nexport const isWindows = () =>\r\n  isBrowser() &&\r\n  // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474\r\n  /^Win/i.test(navigator.userAgentData?.platform || navigator.platform);\r\n\r\n// Make sure we have a HTMLElement to extend (for server side rendering)\r\nexport const DSElement =\r\n  typeof HTMLElement === 'undefined'\r\n    ? (class {} as typeof HTMLElement)\r\n    : HTMLElement;\r\n\r\nexport function debounce<T extends unknown[]>(\r\n  callback: (...args: T) => void,\r\n  delay: number,\r\n) {\r\n  let timer: ReturnType<typeof setTimeout>;\r\n\r\n  return function (this: unknown, ...args: T) {\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => callback.apply(this, args), delay);\r\n  };\r\n}\r\n\r\n/**\r\n * attr\r\n * @description Utility to quickly get, set and remove attributes\r\n * @param el The Element to read/write attributes from\r\n * @param name The attribute name to get, set or remove, or a object to set multiple attributes\r\n * @param value A valid attribute value or null to remove attribute\r\n */\r\nexport const attr = (\r\n  el: Element,\r\n  name: string,\r\n  value?: string | null,\r\n): string | null => {\r\n  if (value === undefined) return el.getAttribute(name) ?? null; // Fallback to null only if el is undefined\r\n  if (value === null) el.removeAttribute(name);\r\n  else if (el.getAttribute(name) !== value) el.setAttribute(name, value);\r\n  return null;\r\n};\r\n\r\n/**\r\n * attrRequiredWarning\r\n * @description Warn if element is missing attribute\r\n * @param el The Element to read/write attributes from\r\n * @param ...names The attribute name(s) check\r\n */\r\nexport const attrRequiredWarning = (el: Element, name: string) =>\r\n  el.hasAttribute(name) ||\r\n  console.warn(`Designsystemet: Missing a ${name} attribute`, el);\r\n\r\n/**\r\n * on\r\n * @param el The Element to use as EventTarget\r\n * @param types A space separated string of event types\r\n * @param listener An event listener function or listener object\r\n */\r\nexport const on = (\r\n  el: Node | Window | ShadowRoot,\r\n  ...rest: Parameters<typeof Element.prototype.addEventListener>\r\n): (() => void) => {\r\n  const [types, ...options] = rest;\r\n  for (const type of types.split(' ')) el.addEventListener(type, ...options);\r\n  return () => off(el, ...rest);\r\n};\r\n\r\n/**\r\n * off\r\n * @param el The Element to use as EventTarget\r\n * @param types A space separated string of event types\r\n * @param listener An event listener function or listener object\r\n */\r\nexport const off = (\r\n  el: Node | Window | ShadowRoot,\r\n  ...rest: Parameters<typeof Element.prototype.removeEventListener>\r\n): void => {\r\n  const [types, ...options] = rest;\r\n  for (const type of types.split(' ')) el.removeEventListener(type, ...options);\r\n};\r\n\r\n// Used to store cleanup functions for hot-reloading\r\ndeclare global {\r\n  interface Window {\r\n    _dsHotReloadCleanup?: Map<string, Array<() => void>>;\r\n  }\r\n}\r\n\r\n/**\r\n * onHotReload\r\n * @description Runs a callback when window is loaded in browser, and ensures cleanup when hot-reloading\r\n * @param key The key to identify setup and corresponding cleanup\r\n * @param callback The callback to run when the page is ready\r\n */\r\nexport const onHotReload = (key: string, setup: () => Array<() => void>) => {\r\n  if (!isBrowser()) return; // Skip if not in modern browser environment, but on each call as Vitest might have unloaded jsdom between tests\r\n  if (!window._dsHotReloadCleanup) window._dsHotReloadCleanup = new Map(); // Hot reload cleanup support supporting all build tools\r\n\r\n  const run = () => {\r\n    window._dsHotReloadCleanup?.get(key)?.map((cleanup) => cleanup()); // Run previous cleanup\r\n    window._dsHotReloadCleanup?.set(key, setup()); // Store new cleanup\r\n  };\r\n\r\n  if (document.readyState !== 'complete') on(window, 'load', run);\r\n  else document.fonts?.ready?.then(run) || setTimeout(run, 0); // Prefer fonts ready promise if available, but fallback to setTimeout\r\n};\r\n\r\n/**\r\n * Speed up MutationObserver by debouncing and only running when page is visible\r\n * @return new MutaionObserver\r\n */\r\nexport const onMutation = (\r\n  el: Node,\r\n  callback: (observer: MutationObserver) => void,\r\n  options: MutationObserverInit & { debounce?: number | false },\r\n) => {\r\n  let queue = 0;\r\n  const { debounce: ms = 200, ...opts } = options;\r\n  const onTimer = () => {\r\n    if (!isBrowser()) return cleanup(); // If using JSDOM, the document might have been removed\r\n    callback(observer);\r\n    observer.takeRecords(); // Clear records to avoid running callback multiple times\r\n    queue = 0;\r\n  };\r\n  const onFrame = ms ? debounce(onTimer, ms) : onTimer; // Use both requestAnimationFrame and setTimeout to debounce and only run when visible\r\n  const cleanup = () => observer?.disconnect?.();\r\n  const observer = new MutationObserver(() => {\r\n    if (!queue) queue = requestAnimationFrame(onFrame); // requestAnimationFrame only runs when page is not visible\r\n  });\r\n\r\n  observer.observe(el, opts);\r\n  onFrame(); // Initial run\r\n  return cleanup;\r\n};\r\n\r\n// Polyfill for ToggleEvent.source for browsers that do not support it yet\r\nif (isBrowser()) {\r\n  let isSupported = false;\r\n  const dialog = document.createElement('dialog');\r\n  dialog.addEventListener('beforetoggle', (e) => {\r\n    isSupported = 'source' in e;\r\n  });\r\n  dialog.show();\r\n\r\n  if (!isSupported) {\r\n    Object.defineProperty(ToggleEvent.prototype, 'source', {\r\n      configurable: true,\r\n      enumerable: true,\r\n      get() {\r\n        const id = this.target.id;\r\n        const root = this.target.getRootNode(); // Support shadow DOM\r\n        const css = `[popovertarget=\"${id}\"],[commandfor=\"${id}\"]`;\r\n        return id ? root?.querySelector?.(css) : null;\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * tag\r\n * @description creates element and assigns properties\r\n * @param tagName The tagname of element to create\r\n * @param attrs Optional attributes to add to the element\r\n * @param text Optional text content to add to the element\r\n * @return HTMLElement with props\r\n */\r\nexport const tag = <TagName extends keyof HTMLElementTagNameMap>(\r\n  tagName: TagName,\r\n  attrs?: Record<string, string | null> | null,\r\n): HTMLElementTagNameMap[TagName] => {\r\n  const el = document.createElement(tagName);\r\n  if (attrs) for (const [key, val] of Object.entries(attrs)) attr(el, key, val);\r\n  return el;\r\n};\r\n\r\n/**\r\n * customElements.define\r\n * @description Defines a customElement if running in browser and if not already registered\r\n * Scoped/named \"customElements.define\" so @custom-elements-manifest/analyzer can find tag names\r\n */\r\nexport const customElements = {\r\n  define: (name: string, instance: CustomElementConstructor) =>\r\n    !isBrowser() ||\r\n    window.customElements.get(name) ||\r\n    window.customElements.define(name, instance),\r\n};\r\n\r\n/**\r\n * useId\r\n * @return A generated unique ID\r\n */\r\nlet id = 0;\r\nconst hash = `${Date.now().toString(36)}${Math.random().toString(36).slice(2, 5)}`;\r\nexport function useId(el?: Element | null) {\r\n  if (el && !el.id) el.id = `${hash}${++id}`;\r\n  return el?.id || '';\r\n}\r\n"],"mappings":"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"}