'use strict';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// ../utils.ts
var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined";
var IS_ANDROID = IS_BROWSER && /android/i.test(navigator.userAgent);
var IS_IOS = IS_BROWSER && /iPad|iPhone|iPod/.test(navigator.userAgent);
var _a;
IS_BROWSER && // @ts-expect-error Typescript has not implemented userAgentData yet https://stackoverflow.com/a/71392474
/^Mac/i.test(((_a = navigator.userAgentData) == null ? void 0 : _a.platform) || navigator.platform);
var SAFE_LABELLEDBY = `${IS_ANDROID ? "data" : "aria"}-labelledby`;
var DISPLAY_BLOCK = ":host(:not([hidden])) { display: block }";
var FOCUS_OUTLINE = "outline: 1px dotted; outline: 5px auto Highlight; outline: 5px auto -webkit-focus-ring-color";
var UHTMLElement = typeof HTMLElement === "undefined" ? class {
} : HTMLElement;
function attr(el, name, value) {
  if (value === void 0) return el.getAttribute(name);
  if (value === null) el.removeAttribute(name);
  else if (el.getAttribute(name) !== value) el.setAttribute(name, value);
  return null;
}
var events = (action, element, rest) => {
  for (const type of rest[0].split(",")) {
    rest[0] = type;
    Element.prototype[`${action}EventListener`].apply(element, rest);
  }
};
var on = (element, ...rest) => events("add", element, rest);
var off = (element, ...rest) => events("remove", element, rest);
var attachStyle = (element, css) => element.shadowRoot || element.attachShadow({ mode: "open" }).append(
  createElement("slot"),
  // Unnamed slot does automatically render all top element nodes
  createElement("style", css)
);
var observers = /* @__PURE__ */ new WeakMap();
var mutationObserver = (element, options) => {
  if (options === void 0) return observers.get(element);
  try {
    observers.get(element).disconnect();
    observers.delete(element);
  } catch (_err) {
  }
  if (options) {
    const observer = new MutationObserver(
      (detail) => element.handleEvent({ type: "mutation", detail })
    );
    observer.observe(element, options);
    observers.set(element, observer);
  }
};
var getRoot = (node) => {
  var _a2;
  const root = ((_a2 = node.getRootNode) == null ? void 0 : _a2.call(node)) || node.ownerDocument;
  return root instanceof Document || root instanceof ShadowRoot ? root : document;
};
var id = 0;
var useId = (el) => {
  if (!el) return "";
  if (!el.id) el.id = `:${el.nodeName.toLowerCase()}${(++id).toString(32)}`;
  return el.id;
};
var createElement = (tagName, content, attrs) => {
  const el = document.createElement(tagName);
  if (content) el[tagName === "style" ? "textContent" : "innerHTML"] = content;
  return el;
};
var customElements = {
  define: (name, instance) => !IS_BROWSER || window.customElements.get(name) || window.customElements.define(name, instance)
};
var LIVE;
var LIVE_SR_FIX = 0;
var speak = (text) => {
  if (!LIVE) {
    LIVE = createElement("div");
    LIVE.style.cssText = "position:fixed;overflow:hidden;width:1px;white-space:nowrap";
    attr(LIVE, "aria-live", "assertive");
  }
  if (!LIVE.isConnected) document.body.append(LIVE);
  if (text) LIVE.textContent = `${text}${LIVE_SR_FIX++ % 2 ? "\xA0" : ""}`;
};
var setValue = (input, data, type = "") => {
  var _a2, _b;
  const event = { bubbles: true, composed: true, data, inputType: type };
  const proto = HTMLInputElement.prototype;
  input.dispatchEvent(new InputEvent("beforeinput", event));
  (_b = (_a2 = Object.getOwnPropertyDescriptor(proto, "value")) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(input, data);
  input.dispatchEvent(new InputEvent("input", event));
  input.dispatchEvent(new Event("change", { bubbles: true }));
};
var IS_PRESS = false;
var isMouseDown = (event) => {
  if ((event == null ? void 0 : event.type) === "mouseup") IS_PRESS = false;
  if ((event == null ? void 0 : event.type) === "mousedown") {
    IS_PRESS = true;
    on(document, "mouseup", isMouseDown, { once: true });
  }
  return IS_PRESS;
};
var declarativeShadowRoot = (style, slot = "<slot></slot>") => `<template shadowrootmode="open">${slot}<style>${style}</style></template>`;

// u-option.ts
var DISABLED = "disabled";
var SELECTED = "selected";
var UHTMLOptionElement = class extends UHTMLElement {
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return [DISABLED, SELECTED];
  }
  connectedCallback() {
    if (!IS_IOS) this.tabIndex = -1;
    if (!this.hasAttribute("role")) attr(this, "role", "option");
    this.attributeChangedCallback();
  }
  attributeChangedCallback() {
    attr(this, "aria-disabled", `${this.disabled}`);
    attr(this, "aria-selected", `${this.selected}`);
  }
  /** Sets or retrieves whether the option in the list box is the default item. */
  get defaultSelected() {
    return this[SELECTED];
  }
  set defaultSelected(value) {
    this[SELECTED] = value;
  }
  get disabled() {
    return attr(this, DISABLED) !== null;
  }
  set disabled(value) {
    attr(this, DISABLED, value ? "" : null);
  }
  /** Retrieves a reference to the form that the object is embedded in. */
  get form() {
    return this.closest("form");
  }
  /** Sets or retrieves the ordinal position of an option in a list box. */
  get index() {
    var _a2;
    return [
      ...((_a2 = this.parentElement) == null ? void 0 : _a2.options) || [this]
    ].indexOf(this);
  }
  /** Sets or retrieves a value that you can use to implement your own label functionality for the object. */
  get label() {
    var _a2;
    return (_a2 = attr(this, "label")) != null ? _a2 : this.text;
  }
  set label(value) {
    attr(this, "label", value);
  }
  get selected() {
    return attr(this, SELECTED) !== null;
  }
  set selected(value) {
    attr(this, SELECTED, value ? "" : null);
  }
  /** Sets or retrieves the text string specified by the option tag. */
  get text() {
    var _a2;
    return ((_a2 = this.textContent) == null ? void 0 : _a2.trim()) || "";
  }
  set text(text) {
    this.textContent = text;
  }
  /** Sets or retrieves the value which is returned to the server when the form control is submitted. */
  get value() {
    var _a2;
    return (_a2 = attr(this, "value")) != null ? _a2 : this.text;
  }
  set value(value) {
    attr(this, "value", value);
  }
};
customElements.define("u-option", UHTMLOptionElement);

// u-datalist.ts
var UHTMLDataListStyle = `${DISPLAY_BLOCK}
::slotted([role="option"]) { display: block; cursor: pointer }
::slotted([role="option"]:focus) { ${FOCUS_OUTLINE} }
::slotted([role="option"][aria-hidden="true"]),
::slotted([role="option"][disabled]),
::slotted([role="option"][hidden]) { display: none !important }`;
var UHTMLDataListShadowRoot = declarativeShadowRoot(UHTMLDataListStyle);
var LIVE_TIMER;
var INPUT_DEBOUNCE = 0;
var IS_MOBILE = IS_IOS || IS_ANDROID;
var EVENTS = "click,focusout,input,keydown,mousedown,mouseup";
var EVENTS_INPUT = "focus,focusin,blur,focusout";
var TEXTS = {
  singular: "%d hit",
  plural: "%d hits"
};
var UHTMLDataListElement = class extends UHTMLElement {
  constructor() {
    super();
    this._texts = __spreadValues({}, TEXTS);
    this._value = "";
    // Used to prevent unnecessary announcements
    this._of = "/";
    attachStyle(this, UHTMLDataListStyle);
  }
  // Can be set by <u-combobox>
  // Using ES2015 syntax for backwards compatibility
  static get observedAttributes() {
    return ["id", ...Object.keys(TEXTS).map((key) => `data-sr-${key}`)];
  }
  connectedCallback() {
    this.hidden = true;
    this._root = getRoot(this);
    attr(this, "role", "listbox");
    attr(this, "tabindex", "-1");
    on(this._root, "focusin", this);
    on(this._root, "focus", this, true);
    mutationObserver(this, {
      attributeFilter: ["disabled", "hidden", "label", "value"],
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    });
    setTimeout(() => this.attributeChangedCallback());
  }
  disconnectedCallback() {
    off(this._root || this, "focus", this, true);
    off(this._root || this, "focusin", this);
    mutationObserver(this, false);
    disconnectInput(this);
    this._root = void 0;
  }
  attributeChangedCallback(prop, _prev, next) {
    const text = prop == null ? void 0 : prop.split("data-sr-")[1];
    const css = `input[list="${this.id}"]`;
    if (TEXTS[text]) this._texts[text] = next || TEXTS[text];
    else if (this._root) {
      if (this._input) setupInput(this, this._input);
      for (const input of this._root.querySelectorAll(css))
        setupInput(this, input);
    }
  }
  handleEvent(event) {
    const { target, type } = event;
    if (event.defaultPrevented) return;
    if (type === "click") onClick(this, event);
    if (type === "focus" || type === "focusin") onFocus(this, event);
    if (type === "blur" || type === "focusout") onBlur(this, event);
    if (type === "keydown") onKeyDown(this, event);
    if (type === "mousedown" && this.contains(target))
      isMouseDown(event);
    if (type === "mutation" || type === "input") {
      clearTimeout(INPUT_DEBOUNCE);
      INPUT_DEBOUNCE = setTimeout(onInput, 0, this, event);
    }
  }
  get options() {
    var _a2;
    if (!this._options) {
      const tag = (_a2 = this.querySelector('[role="option"],option')) == null ? void 0 : _a2.nodeName;
      if (tag) this._options = this.getElementsByTagName(tag);
    }
    return this._options || this.getElementsByTagName("option");
  }
};
var isDisabled = (input) => (input == null ? void 0 : input.disabled) || (input == null ? void 0 : input.readOnly) || false;
var setExpanded = (self, open) => {
  var _a2, _b, _c;
  if (self.hidden !== open) return;
  self.hidden = isDisabled(self == null ? void 0 : self._input) || !open;
  (_a2 = mutationObserver(self)) == null ? void 0 : _a2.takeRecords();
  const isPopover = self.isConnected && self.popover && ((_b = self._input) == null ? void 0 : _b.isConnected) && ((_c = self._input) == null ? void 0 : _c.popoverTargetElement) === self;
  if (self._input) setupInput(self, self._input, open);
  if (isPopover) attr(self, "popover", "manual");
  if (isPopover) self.togglePopover(open);
  if (open) onInput(self);
};
var disconnectInput = (self) => {
  if (!self._input) return;
  off(self._input || self, EVENTS_INPUT, self);
  off(self._root || self, EVENTS, self);
  setExpanded(self, false);
  self._input = void 0;
};
var setupInput = (self, input, open = false) => {
  if (self.popover) attr(input, "popovertarget", useId(self));
  on(input, EVENTS_INPUT, self, true);
  attr(input, "aria-autocomplete", "list");
  attr(input, "aria-controls", useId(self));
  attr(input, "aria-expanded", `${!IS_MOBILE || open}`);
  attr(input, "autocomplete", "off");
  attr(input, "role", isDisabled(input) ? null : "combobox");
};
var onFocus = (self, event) => {
  var _a2;
  const isInput = event.target instanceof HTMLInputElement;
  if (isInput && event.isTrusted) event.stopImmediatePropagation();
  if (self._input !== event.target && isInput && event.target.list === self) {
    if (self._input) disconnectInput(self);
    self._input = event.target;
    self._input.dispatchEvent(new FocusEvent("focus"));
    self._input.dispatchEvent(new FocusEvent("focusin", { bubbles: true }));
    attr(self, SAFE_LABELLEDBY, useId((_a2 = self._input.labels) == null ? void 0 : _a2[0]));
    on(self._root || self, EVENTS, self);
    setExpanded(self, attr(self._input, "inputmode") !== "none");
    speak();
  }
};
var onBlur = (self, event) => {
  if (!IS_ANDROID && !isMouseDown() && self._input)
    setTimeout(onBlurred, 0, self);
  if (event.target === self._input && event.isTrusted)
    event.stopImmediatePropagation();
};
var onBlurred = (self) => {
  var _a2;
  const relatedTarget = ((_a2 = self._root) == null ? void 0 : _a2.activeElement) || null;
  const input = self._input;
  if (input && input !== relatedTarget && !self.contains(relatedTarget)) {
    input.dispatchEvent(new FocusEvent("blur", { relatedTarget }));
    input.dispatchEvent(
      new FocusEvent("focusout", { bubbles: true, relatedTarget })
    );
    disconnectInput(self);
  }
};
var onClick = (self, { target }) => {
  var _a2;
  if (!self._input || self._input === target) return setExpanded(self, true);
  for (const opt of self.options)
    if (opt.contains(target)) {
      if (attr(self, "aria-multiselectable") !== "true") {
        (_a2 = self._input) == null ? void 0 : _a2.focus();
        setExpanded(self, false);
      }
      return setValue(self._input, opt.value);
    }
  if (IS_ANDROID) onBlurred(self);
};
var onKeyDown = (self, e) => {
  var _a2;
  const { key, target, altKey, ctrlKey, shiftKey, metaKey } = e;
  const isEscape = key === "Escape" || key === "Esc";
  if (altKey || ctrlKey || metaKey || shiftKey || key === "Tab") return;
  if (isEscape && !self.hidden) e == null ? void 0 : e.preventDefault();
  setExpanded(self, !isEscape);
  const options = [...self.options].filter(
    (el) => attr(el, "aria-hidden") !== "true" && el.offsetHeight
  );
  const prev = options.indexOf(target);
  let next = -1;
  if (key === "ArrowDown") next = (prev + 1) % options.length;
  if (key === "ArrowUp") next = (~prev ? prev : options.length) - 1;
  if (~prev) {
    if (key === "Home" || key === "PageUp") next = 0;
    if (key === "End" || key === "PageDown") next = options.length - 1;
    if (key === "Enter") {
      options[prev].click();
      return e.preventDefault();
    }
  }
  if (options[next]) for (const option of options) option.tabIndex = -1;
  if (options[next]) e.preventDefault();
  (_a2 = options[next] || self._input) == null ? void 0 : _a2.focus();
  if (!options[next] && key === "ArrowUp")
    setTimeout(() => {
      var _a3;
      return (_a3 = self._input) == null ? void 0 : _a3.setSelectionRange(999, 999);
    });
};
var onInput = (self, e) => {
  const { _texts, _root, _input, options } = self;
  const value = (_input == null ? void 0 : _input.value.toLowerCase().trim()) || "";
  const filter = !self.hasAttribute("data-nofilter");
  const hidden = [];
  const visible = [];
  for (const opt of options) {
    const hide = opt.disabled || opt.hidden || filter && !opt.label.toLowerCase().includes(value);
    (hide ? hidden : visible).push(opt);
  }
  for (const opt of hidden) attr(opt, "aria-hidden", "true");
  for (const opt of visible) attr(opt, "aria-hidden", "false");
  const total = visible.length;
  clearTimeout(LIVE_TIMER);
  if ((e == null ? void 0 : e.type) === "input" && value !== self._value)
    LIVE_TIMER = setTimeout(() => {
      const text = `${!total && self.innerText.trim() || `${_texts[total === 1 ? "singular" : "plural"]}`.replace("%d", `${total}`)}`;
      if (!self.hidden && (_root == null ? void 0 : _root.activeElement) === _input) speak(text);
      self._value = value;
    }, 1e3);
  let idx = 0;
  if (IS_IOS)
    for (const opt of visible)
      attr(opt, "title", `${++idx} ${self._of} ${total}`);
};
if (IS_BROWSER)
  Object.defineProperty(HTMLInputElement.prototype, "list", {
    configurable: true,
    enumerable: true,
    get() {
      return getRoot(this).getElementById(attr(this, "list") || "");
    }
  });
customElements.define("u-datalist", UHTMLDataListElement);

exports.UHTMLDataListElement = UHTMLDataListElement;
exports.UHTMLDataListShadowRoot = UHTMLDataListShadowRoot;
exports.UHTMLDataListStyle = UHTMLDataListStyle;
