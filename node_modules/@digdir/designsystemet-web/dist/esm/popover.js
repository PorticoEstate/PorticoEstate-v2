import { QUICK_EVENT, attr, on, onHotReload } from "./utils.js";
import { autoUpdate, computePosition, flip, limitShift, offset, shift, size } from "@floating-ui/dom";

//#region src/popover.ts
const ATTR_PLACEMENT = "data-placement";
const ATTR_FLOATING = "data-floating";
const ATTR_AUTOPLACEMENT = "data-autoplacement";
const CSS_FLOATING = "--_ds-floating";
const CSS_FLOATING_ARROW_X = "--_ds-floating-arrow-x";
const CSS_FLOATING_ARROW_Y = "--_ds-floating-arrow-y";
const CSS_FLOATING_OVERSCROLL = "--_ds-floating-overscroll";
const POPOVERS = /* @__PURE__ */ new Map();
function handleToggle(event) {
	const { newState, target, source = event.detail } = event;
	if (!isDSFloating(target)) return;
	if (newState === "closed") return POPOVERS.get(target)?.();
	if (!source || source === target) return;
	const padding = 10;
	const overscroll = getCSSProp(target, CSS_FLOATING_OVERSCROLL);
	const placement = attr(target, ATTR_PLACEMENT) || attr(source, ATTR_PLACEMENT) || getCSSProp(target, CSS_FLOATING);
	const shiftOffset = placement.match(/left|right/gi) ? source.offsetHeight : source.offsetWidth;
	const autoPlacement = attr(target, ATTR_AUTOPLACEMENT) || attr(source, ATTR_AUTOPLACEMENT);
	const options = {
		strategy: "absolute",
		placement,
		middleware: [
			offset(parseFloat(getComputedStyle(target, "::before").height) || 0),
			shift({
				padding,
				limiter: limitShift({ offset: { mainAxis: shiftOffset } })
			}),
			arrowPseudo(),
			...autoPlacement !== "false" ? [flip({
				padding,
				crossAxis: false
			})] : [],
			...overscroll ? [size({ apply({ availableHeight }) {
				if (overscroll === "fit") target.style.width = `${source.clientWidth}px`;
				target.style.maxHeight = `${Math.max(50, availableHeight - padding * 2)}px`;
			} })] : []
		]
	};
	const unfloat = autoUpdate(source, target, async () => {
		if (!source?.isConnected) return POPOVERS.get(target)?.();
		const { x, y } = await computePosition(source, target, options);
		target.style.translate = `${x}px ${y}px`;
	});
	POPOVERS.set(target, () => POPOVERS.delete(target) && unfloat());
}
function handleBeforeToggle({ target: el, newState }) {
	if (newState === "open" && isDSFloating(el)) attr(el, "popover", "manual");
}
function handleClickOutside({ target: el }) {
	for (const [popover] of POPOVERS) if (!popover.contains(el)) {
		const id = popover.id;
		const trigger = `[popovertarget="${id}"],[commandfor="${id}"]`;
		if (!el?.closest?.(trigger)) popover.hidePopover();
	}
}
function handleKeydown(event) {
	const last = event.key === "Escape" && Array.from(POPOVERS.keys()).pop();
	if (last) last.hidePopover();
	if (last) event.preventDefault?.();
}
onHotReload("popover", () => [
	on(document, "beforetoggle", handleBeforeToggle, QUICK_EVENT),
	on(document, "click", handleClickOutside, QUICK_EVENT),
	on(document, "keydown", handleKeydown),
	on(document, "toggle ds-toggle-source", handleToggle, QUICK_EVENT)
]);
const getCSSProp = (el, prop) => getComputedStyle(el).getPropertyValue(prop).trim();
const isDSFloating = (el) => el instanceof HTMLElement && !!getCSSProp(el, CSS_FLOATING);
const arrowPseudo = () => ({
	name: "arrowPseudo",
	fn(data) {
		const target = data.elements.floating;
		const source = data.rects.reference;
		const x = `${Math.round(source.width / 2 + source.x - data.x)}px`;
		const y = `${Math.round(source.height / 2 + source.y - data.y)}px`;
		target.style.setProperty(CSS_FLOATING_ARROW_X, x);
		target.style.setProperty(CSS_FLOATING_ARROW_Y, y);
		attr(target, ATTR_FLOATING, data.placement);
		return data;
	}
});

//#endregion
//# sourceMappingURL=popover.js.map